//
//  -2011. All rights reserved.
//
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Runtime.Serialization;
using BaseEntity.Shared;
using BaseEntity.Toolkit.Base.ReferenceIndices;
using BaseEntity.Toolkit.Base;
using BaseEntity.Toolkit.Base.Serialization;
using BaseEntity.Toolkit.Cashflows;
using BaseEntity.Toolkit.Curves;
using BaseEntity.Toolkit.Models.Simulations;
using BaseEntity.Toolkit.Pricers;
using BaseEntity.Toolkit.Products;
using BaseEntity.Toolkit.Ccr;
using BaseEntity.Toolkit.Sensitivity;
using BaseEntity.Toolkit.Util;

namespace BaseEntity.Toolkit.Ccr
{
  /// <summary>
  /// Compute Pv by Least Squares Monte Carlo using a multi-factor, multi-currency, multi-asset class market model.
  /// Price generic products whose fair price is given by <m>\sup_{\eta}\inf_{\tau}E\left(\sum_{t_i \leq \eta \wedge \tau} c_i + C_{\tau} I_{\{\tau \leq \eta \}} + P_{\eta} I_{\{\eta \leq \tau\}}\right)</m>
  /// Where <m>P_t</m> is the put price process, and <m>C_t</m> is the call price process and <m>P_t \leq C_t</m>
  /// </summary>
  [Serializable]
  public class LeastSquaresMonteCarloCcrPricer : IPricer, IAmericanMonteCarloAdapter
  {
    #region DummyProduct

    [Serializable]
    private class DummyProduct : Product
    {
      public DummyProduct(Dt effective, Dt maturity, Currency ccy)
        : base(effective, maturity, ccy)
      {}
    }

    #endregion

    #region Methods

    /// <summary>
    /// Compute Pv by Least Squares Monte Carlo using a multi-factor, multi-currency, multi-asset class market model.
    /// Price generic products whose fair price is given by <m>\sup_{\eta}\inf_{\tau}E\left(\sum_{t_i \leq \eta \wedge \tau} c_i + C_{\tau} I_{\{\tau \leq \eta \}} + P_{\eta} I_{\{\eta \leq \tau\}}\right)</m>
    /// Where <m>P_t</m> is the put price process, and <m>C_t</m> is the call price process
    /// </summary>
    /// <param name="asOf">As of date</param>
    /// <param name="gridSize">Grid size for simulation step</param>
    /// <param name="simulationDates">Dates at which to simulate the market environment. 
    /// Market environments on interim dates are generated by as the <m>L^2</m> projection, 
    /// on immediately preceding and immediately following realized market environments.
    /// </param>
    /// <param name="pathCount">Number of realizations</param>
    /// <param name="rngType">Type of MultiStream random number generator</param>
    /// <param name="rateCurves">Underlying discount curves</param>
    /// <param name="volatilities">Libor rate volatilities</param>
    /// <param name="factorLoadings">Libor rate factor loadings</param>
    /// <param name="fxRates">Underlying spot FX rates</param>
    /// <param name="fwdPriceCurves">Underlying forward price curves</param>
    /// <param name="creditCurves">Underlying survival curves</param>
    /// <param name="notional">Trade notional in numeraire currency</param>
    /// <param name="pvCurrency">Denomination currency of underlyingAsset, Call and Put</param>
    /// <param name="numeraireCurrency">Numeraire currency</param>
    /// <param name="underlyingCashflow">Stream of cashflows to be paid up to exercise date</param>
    /// <param name="basis">Basis</param>
    /// <param name="call">Call exercise exerciseEvaluator</param>
    /// <param name="put">Put exercise exerciseEvaluator</param>
    /// <param name="svdTolerance">The singular values whose magnitude is less than svdTolerance * maximum singular value are zeroed in order to make the Least Squares problem stable.</param>
    /// <param name="reportDates">Report pv per path on report dates</param>
    ///<remarks>Pv is converted to the numeraire currency</remarks>
    internal static double[,] Calculate(
      Dt asOf, Dt[] tenors,
      Tenor gridSize,
      IList<Dt> simulationDates,
      int pathCount,
      MultiStreamRng.Type rngType,
      DiscountCurve[] rateCurves,
      FxRate[] fxRates,
      CalibratedCurve[] fwdPriceCurves,
      SurvivalCurve[] creditCurves,
      VolatilityCollection volatilities,
      FactorLoadingCollection factorLoadings,
      double notional,
      Currency pvCurrency,
      Currency numeraireCurrency,
      IList<ICashflowNode> underlyingCashflow,
      BasisFunctions basis,
      ExerciseEvaluator call,
      ExerciseEvaluator put,
      double svdTolerance,
      Dt[] reportDates)
    {
      if (volatilities == null || factorLoadings == null)
        throw new ToolkitException("Require non null rateVolatilities and rateFactorCorrelations");
      var environment = MarketEnvironment.Create(asOf, tenors, gridSize, pvCurrency, numeraireCurrency, volatilities, factorLoadings, rateCurves,
                                       fxRates, fwdPriceCurves, creditCurves);
      call = call.ToCcrExerciseEvaluator(underlyingCashflow);
      put = put.ToCcrExerciseEvaluator(underlyingCashflow);
      var partition = Simulator.GetDefaultSimulationDates(asOf, simulationDates, underlyingCashflow, call, put, gridSize);
      using (var simulator = Simulator.Create(pathCount, partition, environment,
                                                         volatilities, factorLoadings, EmptyArray<int>.Instance, -100.0))
      {
        
        var retVal = LeastSquaresMonteCarloPricingEngine.Calculate(notional, environment, simulator, rngType,
                                                                   numeraireCurrency, underlyingCashflow,
                                                                   basis ??
                                                                   BasisFunctions.GetDefaultBasisFunctions(underlyingCashflow, call, put),
                                                                   call, put, svdTolerance, reportDates);
        return retVal;
      }
    }

	  ///  <summary>
	  ///  Compute Pv by Least Squares Monte Carlo using a multi-factor, multi-currency, multi-asset class market model.
	  ///  Price generic products whose fair price is given by <m>\sup_{\eta}\inf_{\tau}E\left(\sum_{t_i \leq \eta \wedge \tau} c_i + C_{\tau} I_{\{\tau \leq \eta \}} + P_{\eta} I_{\{\eta \leq \tau\}}\right)</m>
	  ///  Where <m>P_t</m> is the put price process, and <m>C_t</m> is the call price process
	  ///  </summary>
	  /// <param name="notional"></param>
	  /// <param name="numeraireCurrency">Numeraire currency</param>
	  ///  <param name="underlyingCashflow">Stream of cashflows to be paid up to exercise date</param>
	  ///  <param name="basis">Basis</param>
	  ///  <param name="call">Call exercise exerciseEvaluator</param>
	  ///  <param name="put">Put exercise exerciseEvaluator</param>
	  ///  <param name="svdTolerance">The singular values whose magnitude is less than svdTolerance * maximum singular value are zeroed in order to make the Least Squares problem stable.</param>
	  ///  <param name="reportDates">Report pv per path on report dates</param>
	  /// <param name="getPath"></param>
	  /// <param name="environment"></param>
	  /// <param name="simulator"></param>
	  /// <remarks>Pv is converted to the numeraire currency</remarks>
	  public static Tuple<double[,], double[,]> Calculate(
			double notional,
			Currency numeraireCurrency,
			IList<ICashflowNode> underlyingCashflow,
			BasisFunctions basis,
			ExerciseEvaluator call,
			ExerciseEvaluator put,
			double svdTolerance,
			Dt[] reportDates, 
			Func<int, SimulatedPath> getPath, 
			MarketEnvironment environment,
			Simulator simulator)
		{
			call = call.ToCcrExerciseEvaluator(underlyingCashflow);
			put = put.ToCcrExerciseEvaluator(underlyingCashflow);
			
			var retVal = LeastSquaresMonteCarloPricingEngine.Calculate(notional, environment, simulator, 
																																	numeraireCurrency, underlyingCashflow,
																																	basis ??
																																	BasisFunctions.GetDefaultBasisFunctions(underlyingCashflow, call, put),
																																	call, put, svdTolerance, reportDates, getPath);
			return retVal;
			
		}

    /// <summary>
    /// Compute array of perturbed Pvs by Least Squares Monte Carlo using a multi-factor, multi-currency, multi-asset class market model.
    /// Price generic products whose fair price is given by <m>\sup_{\eta}\inf_{\tau}E\left(\sum_{t_i \leq \eta \wedge \tau} c_i + C_{\tau} I_{\{\tau \leq \eta \}} + P_{\eta} I_{\{\eta \leq \tau\}}\right)</m>
    /// Where <m>P_t</m> is the put price process, and <m>C_t</m> is the call price process
    /// </summary>
    /// <param name="asOf">As of date</param>
    /// <param name="tenors">tenors</param>
    /// <param name="gridSize">Grid size for simulation step</param>
    /// <param name="simulationDates">Dates at which to simulate the market environment. 
    /// Market environments on interim dates are generated by as the <m>L^2</m> projection, 
    /// on immediately preceding and immediately following realized market environments.
    /// </param>
    /// <param name="pathCount">Number of realizations</param>
    /// <param name="rngType">Type of MultiStream random number generator</param>
    /// <param name="rateCurves">Underlying discount curves</param>
    /// <param name="volatilities">Libor rate volatilities</param>
    /// <param name="factorLoadings">Libor rate factor loadings</param>
    /// <param name="fxRates">Underlying spot FX rates</param>
    /// <param name="fwdPriceCurves">Underlying forward price curves</param>
    /// <param name="creditCurves">Underlying survival curves</param>
    /// <param name="notional">Trade notional</param>
    /// <param name="pvCurrency">Denomination currency of underlyingAsset, Call and Put</param>
    /// <param name="numeraireCurrency">Numeraire currency</param>
    /// <param name="underlyingCashflow">Stream of cashflows to be paid up to exercise date</param>
    /// <param name="basis">Basis</param>
    /// <param name="call">Call exercise exerciseEvaluator</param>
    /// <param name="put">Put exercise exerciseEvaluator</param>
    /// <param name="svdTolerance">The singular values whose magnitude is less than svdTolerance * maximum singular value are zeroed in order to make the Least Squares 
    /// problem stable.</param>
    /// <param name="perturbations">Perturbations</param>
    /// <param name="reportDates">Report pv per path on report dates</param>
    ///<remarks>Pv is converted to the numeraire currency</remarks>
    internal static double[][,] Calculate(
      Dt asOf, Dt[] tenors,
      Tenor gridSize,
      IList<Dt> simulationDates,
      int pathCount,
      MultiStreamRng.Type rngType,
      DiscountCurve[] rateCurves,
      FxRate[] fxRates,
      CalibratedCurve[] fwdPriceCurves,
      SurvivalCurve[] creditCurves,
      VolatilityCollection volatilities,
      FactorLoadingCollection factorLoadings,
      double notional,
      Currency pvCurrency,
      Currency numeraireCurrency,
      IList<ICashflowNode> underlyingCashflow,
      BasisFunctions basis,
      ExerciseEvaluator call,
      ExerciseEvaluator put,
      double svdTolerance,
      Simulations.Perturbation[] perturbations,
      Dt[] reportDates)
    {
      if (volatilities == null || factorLoadings == null)
        throw new ToolkitException("Require non null rateVolatilities and rateFactorCorrelations");
      var environment = MarketEnvironment.Create(asOf, tenors, gridSize, pvCurrency, numeraireCurrency, volatilities, factorLoadings, rateCurves,
                                       fxRates, fwdPriceCurves, creditCurves);
      call = call.ToCcrExerciseEvaluator(underlyingCashflow);
      put = put.ToCcrExerciseEvaluator(underlyingCashflow);
      var partition = Simulator.GetDefaultSimulationDates(asOf, simulationDates, underlyingCashflow, call, put, gridSize);
      using (var simulator = Simulator.Create(pathCount, partition, environment, volatilities, factorLoadings, EmptyArray<int>.Instance, -100.0))
      {
        var perturbedSimulators =
          perturbations.Select(p => (p == null || !p.References.Any(simulator.Map.ContainsKey)) ? null : p.GetPerturbedSimulator(simulator).Item1).ToArray
            ();
        
        var retVal = LeastSquaresMonteCarloPricingEngine.Calculate(notional, environment, perturbedSimulators, simulator,
                                                                   rngType, numeraireCurrency, underlyingCashflow,
                                                                   basis ?? BasisFunctions.GetDefaultBasisFunctions(underlyingCashflow, call, put), call,
                                                                   put, svdTolerance, reportDates).ToArray();
        foreach (var sim in perturbedSimulators)
        {
          if (sim != null)
            sim.Dispose();
        }
        return retVal;
      }
    }

    #endregion

    #region Constructors

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="description">Pricer id</param>
    /// <param name="asOf">As of date</param>
    /// <param name="settle">Settle date</param>
    /// <param name="notional">Notional</param>
    /// <param name="valuationCurrency">Valuation currency</param>
    /// <param name="underlierCashflow">Cashflow to be received/paid until exercise date</param>
    /// <param name="call">Call exercise price process</param>
    /// <param name="put">Put exercise price process</param>
    /// <param name="fundingCurves">Underlying curves used for discounting</param>
    /// <param name="fxRates">Underlying FX rates</param>
    /// <param name="referenceCurves">Underlying curves used for coupon fixing</param>
    /// <param name="survivalCurves">Underlying survival curves </param>
    /// <param name="basis">Basis function</param>
    ///<remarks>If Basis is null, a set of default basis function is chosen as follows, 
    /// let <m>x</m> be the forward value of the underlierCashflow (if non null), <m>y</m> be the call price (if non null and analytic), and <m>z</m> be the put price (if non null and analytic), then 
    /// the basis vector is given by <m>[1, x, y, z, x^2, y^2, z^2, xy, xz, yz, x^3, y^3, z^3, x^2y, x^2z, z^2x, z^2y, y^2x, y^2z, xyz]</m>
    /// 
    /// The notional of the underlyingCashflow, Call and Put denominated in ValuationCurrency should be 1.0 to avoid overflow in computation.
    /// </remarks>
    public LeastSquaresMonteCarloCcrPricer(
      string description,
      Dt asOf,
      Dt settle,
      double notional,
      Currency valuationCurrency,
      IList<ICashflowNode> underlierCashflow,
      ExerciseEvaluator call,
      ExerciseEvaluator put,
      DiscountCurve[] fundingCurves,
      FxRate[] fxRates,
      CalibratedCurve[] referenceCurves,
      SurvivalCurve[] survivalCurves,
      BasisFunctions basis
      )
    {
      AsOf = asOf;
      Settle = settle;
      Product = new DummyProduct(settle, TerminationDate, valuationCurrency) {Description = description};
      Notional = notional;
      ValuationCurrency = valuationCurrency;
      UnderlierCashflow = underlierCashflow;
      Call = call;
      Put = put;
      Basis = basis;
      DiscountCurves = fundingCurves;
      FxRates = fxRates;
      ReferenceCurves = referenceCurves;
      SurvivalCurves = survivalCurves;
    }

    #endregion

    #region IAmericanMonteCarloAdapter Members

    /// <summary>
    /// Underlying discount curves
    /// </summary>
    IEnumerable<DiscountCurve> IAmericanMonteCarloAdapter.DiscountCurves
    {
      get { return DiscountCurves; }
    }

    /// <summary>
    /// Underlying forward curves
    /// </summary>
    IEnumerable<CalibratedCurve> IAmericanMonteCarloAdapter.ReferenceCurves
    {
      get { return ReferenceCurves; }
    }

    /// <summary>
    /// Underlying survival curves
    /// </summary>
    IEnumerable<SurvivalCurve> IAmericanMonteCarloAdapter.SurvivalCurves
    {
      get { return SurvivalCurves; }
    }

    /// <summary>
    /// Underlying FX rates
    /// </summary>
    IEnumerable<FxRate> IAmericanMonteCarloAdapter.FxRates
    {
      get { return FxRates; }
    }

    /// <summary>
    /// Cashflow up to call/put time
    /// </summary>
    IList<ICashflowNode> IAmericanMonteCarloAdapter.Cashflow
    {
      get { return UnderlierCashflow; }
    }

    /// <summary>
    /// Call right
    /// </summary>
    ExerciseEvaluator IAmericanMonteCarloAdapter.CallEvaluator
    {
      get { return Call; }
    }

    /// <summary>
    /// Put right
    /// </summary>
    ExerciseEvaluator IAmericanMonteCarloAdapter.PutEvaluator
    {
      get { return Put; }
    }

    /// <summary>
    /// Notional
    /// </summary>
    double IAmericanMonteCarloAdapter.Notional
    {
      get { return Notional; }
    }

    /// <summary>
    /// Explanatory variables for regression algorithm. 
    /// </summary>
    BasisFunctions IAmericanMonteCarloAdapter.Basis
    {
      get { return Basis; }
    }

    /// <summary>
    /// Check if pricer is vanilla
    /// </summary>
    bool IAmericanMonteCarloAdapter.Exotic
    {
      get { return true; }
    }

    /// <summary>
    /// Exposure dates
    /// </summary>
		public Dt[] ExposureDates
		{
			get
			{
				if (_exposureDts == null)
				{
					_exposureDts = InitExposureDates(null);
				}

				return _exposureDts; 
			}
			set { _exposureDts = InitExposureDates(value); }
		}

	  private Dt[] InitExposureDates(Dt[] inputDates)
	  {
		  Dt max = TerminationDate;
		  var dates = new UniqueSequence<Dt>();
		  if(inputDates != null && inputDates.Any(dt => dt <= max))
		  {
		    dates.Add(inputDates.Where(dt => dt <= max).ToArray());
        var lastDt = dates.Max();
        if (lastDt < max && inputDates.Any(dt => dt > max))
          dates.Add(inputDates.First(dt => dt > max)); 
			  max = Dt.Earlier(inputDates.First(), max);
		  }
			if (Put != null)
			{
				foreach (var exDt in Put.ExerciseDates)
				{
					if(exDt > max)
						break;
					var beforeDt = Dt.Add(exDt, -1);
					if (beforeDt > AsOf)
						dates.Add(beforeDt);
					dates.Add(exDt);
				}
				if (Put.EventDates != null)
				{
					foreach (var eventDate in Put.EventDates)
					{
						if (eventDate > max)
							break;
            var beforeDt = Dt.Add(eventDate, -1);
						if (beforeDt > AsOf)
							dates.Add(beforeDt);
						dates.Add(eventDate);
					}
				}
			}

			if (Call != null)
			{
				foreach (var exDt in Call.ExerciseDates)
				{
					if (exDt > max)
						break;
          var beforeDt = Dt.Add(exDt, -1);
					if (beforeDt > AsOf)
						dates.Add(beforeDt);
					dates.Add(exDt);
				}

				if (Call.EventDates != null)
				{
					foreach (var eventDate in Call.EventDates)
					{
						if (eventDate > max)
							break;
            var beforeDt = Dt.Add(eventDate, -1);
						if (beforeDt > AsOf)
							dates.Add(beforeDt);
						dates.Add(eventDate);
					}
				}
			}

			if (!dates.Any())
			{
				if (UnderlierCashflow != null)
				{
					foreach (var cashflowNode in UnderlierCashflow)
					{
						dates.Add(cashflowNode.PayDt);
					}
				}
			}

			dates.Add(AsOf);	
		  return dates.ToArray();
	  }

	  #endregion

    #region IPricer Members

    /// <summary>
    /// Present value 
    /// </summary>
    /// <returns>Trade pv</returns>
    public double Pv()
    {
      var grid = Calculate(
        AsOf, null,
        GridSize,
        SimulationDates,
        PathCount,
        RngType,
        DiscountCurves,
        FxRates,
        ReferenceCurves,
        SurvivalCurves,
        Volatilities,
        FactorLoadings,
        Notional,
        ValuationCurrency,
        ValuationCurrency,
        UnderlierCashflow,
        Basis,
        Call,
        Put,
        (SvdTolerance > 0.0) ? SvdTolerance : 1e-8, null);
      return grid[0, 0];
    }

    /// <summary>
    /// Accrued
    /// </summary>
    /// <returns></returns>
    public double Accrued()
    {
      return 0.0;
    }

    /// <summary>
    /// Generate cashflows
    /// </summary>
    /// <param name="cashflow"></param>
    /// <param name="from"></param>
    /// <returns></returns>
    public Cashflow GenerateCashflow(Cashflow cashflow, Dt from)
    {
      throw new NotImplementedException();
    }

    /// <summary>
    /// 
    /// </summary>
    public void Reset()
    {}

    /// <summary>
    /// Pricing date
    /// </summary>
    public Dt AsOf { get; set; }

    /// <summary>
    /// Settlement date
    /// </summary>
    public Dt Settle { get; set; }

    /// <summary>
    /// Product
    /// </summary>
    public IProduct Product { get; set; }

    /// <summary>
    /// Settlement date
    /// </summary>
    public IPricer PaymentPricer
    {
      get { return null; }
    }

    /// <summary>
    /// Pv currency
    /// </summary>
    public Currency ValuationCurrency { get; set; }

    /// <summary>
    /// Memberwise clone
    /// </summary>
    /// <returns>Clone</returns>
    public object Clone()
    {
      return new LeastSquaresMonteCarloCcrPricer(Product.Description, AsOf, Settle, Notional, ValuationCurrency, UnderlierCashflow, Call,
                                                 Put, DiscountCurves, FxRates, ReferenceCurves, SurvivalCurves, Basis)
             {
               PathCount = PathCount,
               SimulationDates = SimulationDates,
               RngType = RngType,
               Volatilities = Volatilities,
               FactorLoadings = FactorLoadings,
               CashSettled = CashSettled,
               SvdTolerance = SvdTolerance,
               GridSize = GridSize
             };
    }

    #endregion

    #region Properties

    /// <summary>
    /// Notional
    /// </summary>
    public double Notional { get; set; }

    /// <summary>
    /// Cash vs. Physical settlement flag
    /// </summary>
    public bool CashSettled { get; set; }

    /// <summary>
    /// Underlying funding zeros term structure 
    /// </summary>
    public DiscountCurve DiscountCurve
    {
      get { return (DiscountCurves == null) ? null : (DiscountCurves.Length == 1) ? DiscountCurves[0] : DiscountCurves.First(dc => dc.Ccy == ValuationCurrency); }
    }

    /// <summary>
    /// Underlying funding zeros term structure 
    /// </summary>
    public DiscountCurve[] DiscountCurves { get; private set; }

    /// <summary>
    /// Underlying reference curves (any curve that represents a term structure of processes <m>X_t(T)</m> that are 
    /// martingales under the T-forward measure associated to the funding numeraire process  
    /// </summary>
    public CalibratedCurve[] ReferenceCurves { get; private set; }

    /// <summary>
    /// Underlying survival probability term structures
    /// </summary>
    public SurvivalCurve[] SurvivalCurves { get; private set; }

    /// <summary>
    /// Underlying FX rates
    /// </summary>
    public FxRate[] FxRates { get; private set; }

    /// <summary>
    /// Funding rates volatilities
    /// </summary>
    public VolatilityCollection Volatilities { get; set; }

    /// <summary>
    /// Funding rates factor loadings
    /// </summary>
    public FactorLoadingCollection FactorLoadings { get; set; }

    /// <summary>
    /// Basis functions
    /// </summary>
    public BasisFunctions Basis { get; set; }

    /// <summary>
    /// Cashflow received up to exercise
    /// </summary>
    public IList<ICashflowNode> UnderlierCashflow { get; private set; }

    /// <summary>
    /// Call price 
    /// </summary>
    public ExerciseEvaluator Call { get; private set; }

    /// <summary>
    /// Put price
    /// </summary>
    public ExerciseEvaluator Put { get; private set; }

    /// <summary>
    /// Dates at which to simulate underlying market environmnt
    /// </summary>
    public IList<Dt> SimulationDates { get; set; }

    /// <summary>
    /// Random number generator  
    /// </summary>
    public MultiStreamRng.Type RngType { get; set; }

    /// <summary>
    /// Number of paths
    /// </summary>
    public int PathCount { get; set; }

    /// <summary>
    /// The singular values whose magnitde is less than epsilon * maximum singular value are zeroed in order to make the Least Squares 
    /// problem stable. By default epsilon = 1e-8;
    /// </summary>
    public double SvdTolerance { get; set; }

    /// <summary>
    /// Grid size for simulation step
    /// </summary>
    public Tenor GridSize { get; set; }

    private Dt TerminationDate
    {
      get
      {
        var dts = new List<Dt>();
        if (UnderlierCashflow != null)
          dts.Add(UnderlierCashflow.Last().PayDt);
        if (Put != null)
          dts.Add(Put.TerminationDate);
        if (Call != null)
          dts.Add(Call.TerminationDate);
        dts = dts.Where(dt => dt.IsValid()).ToList();
        return (dts.Count == 0) ? AsOf : dts.Max();
      }
    }

    #endregion

    #region Risk Methods

    #region Utilities

    private DataTable GenerateSensitivitiesTable(Tuple<Simulations.Perturbation[], bool> perturbations,
                                                 DataTable dataTable)
    {
      var grids = Calculate(
        AsOf, null,
        GridSize,
        SimulationDates,
        PathCount,
        RngType,
        DiscountCurves,
        FxRates,
        ReferenceCurves,
        SurvivalCurves,
        Volatilities,
        FactorLoadings,
        Notional,
        ValuationCurrency,
        ValuationCurrency,
        UnderlierCashflow,
        Basis,
        Call,
        Put,
        (SvdTolerance > 0) ? SvdTolerance : 1e-8,
        perturbations.Item1,
        null);
      return TabulateSensitivities(perturbations, Array.ConvertAll(grids, g => g[0, 0]), dataTable);
    }

    private static DataTable TabulateSensitivities(Tuple<Simulations.Perturbation[], bool> perturbationData,
                                                   double[] pvs, DataTable dataTable)
    {
      var perturbations = perturbationData.Item1;
      bool calcGamma = perturbationData.Item2;
      int offset = calcGamma ? 2 : 1;
      if (dataTable == null) // Create DataTable if we need to
      {
        dataTable = new DataTable("Sensitivity Report");
        dataTable.Columns.Add(new DataColumn("InputName", typeof(string)));
        dataTable.Columns.Add(new DataColumn("Tenor", typeof(string)));
        dataTable.Columns.Add(new DataColumn("Delta", typeof(double)));
        if (calcGamma)
          dataTable.Columns.Add(new DataColumn("Gamma", typeof(double)));
      }
      for (int i = 0, j = 1; i < perturbations.Length; i += offset, j += offset)
      {
        var dataRow = dataTable.NewRow();
        dataRow["InputName"] = perturbations[i].Id;
        dataRow["Tenor"] = perturbations[i].Tenor;
        dataRow["Delta"] = pvs[j] - pvs[0];
        if (calcGamma)
          dataRow["Gamma"] = pvs[j] + pvs[j + 1] - 2 * pvs[0];
        dataTable.Rows.Add(dataRow);
      }
      return dataTable;
    }

    #endregion

    #region Rates

    /// <summary>
    /// Calculate the libor rates sensitivity 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    ///<param name="targetQuoteType">Target quote type</param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable RateSensitivities(double upBump, double downBump, bool bumpRelative, BumpType bumpType,
                                       QuotingConvention targetQuoteType, string[] bumpTenors,
                                       bool calcGamma, DataTable dataTable)
    {
      var dc = DiscountCurves;
      if (dc == null || dc.Length == 0)
        return new DataTable();
      if (Volatilities == null || FactorLoadings == null)
        throw new ToolkitException("Require non null DiscountRateVolatilities and DiscountRateFactors");
      var perturbations = Simulations.Perturbation.GenerateTermStructurePerturbations(dc, upBump,
                                                                                      downBump, bumpRelative,
                                                                                      bumpType, targetQuoteType,
                                                                                      bumpTenors, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }

    /// <summary>
    ///   Calculate the libor volatility sensitivities 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable RateVolatilitiesSensitivities(double upBump, double downBump, bool bumpRelative, BumpType bumpType,
                                                   string[] bumpTenors,
                                                   bool calcGamma, DataTable dataTable)
    {
      var dc = DiscountCurves;
      if (dc == null || dc.Length == 0)
        return new DataTable();
      if (Volatilities == null || FactorLoadings == null)
        throw new ToolkitException("Require non null DiscountRateVolatilities and DiscountRateFactors");
      var perturbations = Simulations.Perturbation.GenerateVolatilityPerturbations(dc,
                                                                                   Volatilities,
                                                                                   upBump, downBump, bumpRelative,
                                                                                   bumpType, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }


    /// <summary>
    ///   Calculate the factor loading sensitivities 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    ///<param name="bumpType">Bump type</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable RateFactorsSensitivities(double[] upBump, double[] downBump, bool bumpRelative,
                                              BumpType bumpType, bool calcGamma, DataTable dataTable)
    {
      var dc = DiscountCurves;
      if (dc == null || dc.Length == 0)
        return new DataTable();
      if (Volatilities == null || FactorLoadings == null)
        throw new ToolkitException("Require non null DiscountRateVolatilities and DiscountRateFactors");
      var perturbations = Simulations.Perturbation.GenerateFactorPerturbations(dc, FactorLoadings,
                                                                               upBump, downBump,
                                                                               bumpRelative, bumpType, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }

    #endregion

    #region FX

    /// <summary>
    ///   Calculate the fx sensitivity 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    ///<param name="bumpType">Bump type</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable FxSensitivities(double upBump, double downBump, bool bumpRelative, BumpType bumpType,
                                     bool calcGamma, DataTable dataTable)
    {
      var fx = FxRates;
      if (fx == null || fx.Length == 0)
        return new DataTable();
      if (Volatilities == null || FactorLoadings == null)
        throw new ToolkitException("Require non null DiscountRateVolatilities and DiscountRateFactors");
      var perturbations = Simulations.Perturbation.GenerateTermStructurePerturbations(fx, upBump,
                                                                                      downBump, bumpRelative,
                                                                                      bumpType, QuotingConvention.None,
                                                                                      null, calcGamma);

      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }


    /// <summary>
    ///   Calculate the fx volatility sensitivities 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable FxVolatilitiesSensitivities(double upBump, double downBump,
                                                 bool bumpRelative, BumpType bumpType, string[] bumpTenors,
                                                 bool calcGamma, DataTable dataTable)
    {
      var fx = FxRates;
      if (fx == null || fx.Length == 0)
        return new DataTable();
      if (Volatilities == null || FactorLoadings == null)
        throw new ToolkitException("Require non null DiscountRateVolatilities and DiscountRateFactors");
      var perturbations = Simulations.Perturbation.GenerateVolatilityPerturbations(fx,
                                                                                   Volatilities,
                                                                                   upBump, downBump, bumpRelative,
                                                                                   bumpType, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }


    /// <summary>
    ///   Calculate the fx factor loading sensitivities
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    ///<param name="bumpType">Bump type</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable FxFactorsSensitivities(double[] upBump, double[] downBump, bool bumpRelative,
                                            BumpType bumpType, bool calcGamma, DataTable dataTable)
    {
      var fx = FxRates;
      if (fx == null || fx.Length == 0)
        return new DataTable();
      if (Volatilities == null || FactorLoadings == null)
        throw new ToolkitException("Require non null DiscountRateVolatilities and DiscountRateFactors");
      var perturbations = Simulations.Perturbation.GenerateFactorPerturbations(fx, FactorLoadings,
                                                                               upBump, downBump, bumpRelative,
                                                                               bumpType, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }

    #endregion

    #region Credit

    /// <summary>
    ///   Calculate the spread sensitivity 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    ///<param name="targetQuoteType"></param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable CreditSpreadSensitivities(double upBump, double downBump, bool bumpRelative,
                                               BumpType bumpType, QuotingConvention targetQuoteType,
                                               string[] bumpTenors,
                                               bool calcGamma, DataTable dataTable)
    {
      var sc = SurvivalCurves;
      if (sc == null || sc.Length == 0)
        return new DataTable();
      var perturbations = Simulations.Perturbation.GenerateTermStructurePerturbations(sc, upBump,
                                                                                      downBump, bumpRelative,
                                                                                      bumpType, targetQuoteType,
                                                                                      bumpTenors, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }


    /// <summary>
    /// Calculate the spread volatility sensitivities 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable CreditVolatilitiesSensitivities(double upBump, double downBump,
                                                     bool bumpRelative, BumpType bumpType, string[] bumpTenors,
                                                     bool calcGamma, DataTable dataTable)
    {
      var sc = SurvivalCurves;
      if (sc == null || sc.Length == 0)
        return new DataTable();
      var perturbations = Simulations.Perturbation.GenerateVolatilityPerturbations(sc, Volatilities, upBump,
                                                                                   downBump, bumpRelative, bumpType, calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }


    /// <summary>
    ///   Calculate the spread factor loading sensitivities 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    ///<param name="bumpType">Bump type</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable CreditFactorsSensitivities(double[] upBump, double[] downBump, bool bumpRelative,
                                                BumpType bumpType, bool calcGamma, DataTable dataTable)
    {
      var sc = SurvivalCurves;
      if (sc == null || sc.Length == 0)
        return new DataTable();
      var perturbations = Simulations.Perturbation.GenerateFactorPerturbations(sc, FactorLoadings,
                                                                               upBump, downBump, bumpRelative, bumpType,
                                                                               calcGamma);
      dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      return dataTable ?? new DataTable();
    }

    #endregion

    #region Reference

    /// <summary>
    ///   Calculate the forward price (could be inflation, commodity price, stock price, etc.) sensitivity 
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    ///<param name="targetQuoteType">Target quote type</param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable ReferenceSensitivities(double upBump, double downBump, bool bumpRelative,
                                            BumpType bumpType, QuotingConvention targetQuoteType,
                                            string[] bumpTenors, bool calcGamma, DataTable dataTable)
    {
      if (ReferenceCurves != null && ReferenceCurves.Any())
      {
        var fwd =
          ReferenceCurves.GetForwardBased(Volatilities, FactorLoadings).Cast<object>().Union(
            ReferenceCurves.GetSpotBased(Volatilities, FactorLoadings).Cast<IForwardPriceCurve>().Select(p => p.Spot)).ToArray();
        var perturbations = Simulations.Perturbation.GenerateTermStructurePerturbations(fwd, upBump,
                                                                                        downBump, bumpRelative,
                                                                                        bumpType, QuotingConvention.None,
                                                                                        null, calcGamma);
        dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      }
      return dataTable ?? new DataTable();
    }


    /// <summary>
    ///   Calculate the the forward price volatility (could be inflation, commodity price, stock price, etc.) sensitivities for CVA, DVA, EEs and NEEs
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    /// <param name="bumpType">Type of bump to apply</param>
    /// <param name="bumpTenors">List of individual tenors to bump (null or empty = all tenors)</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable ReferenceVolatilitiesSensitivities(double upBump, double downBump,
                                                        bool bumpRelative, BumpType bumpType,
                                                        string[] bumpTenors,
                                                        bool calcGamma, DataTable dataTable)
    {
      if (ReferenceCurves != null && ReferenceCurves.Any())
      {
        var fwd = ReferenceCurves.GetForwardBased(Volatilities, FactorLoadings).Cast<object>().Union(
          ReferenceCurves.GetSpotBased(Volatilities, FactorLoadings).Cast<IForwardPriceCurve>().Select(p => p.Spot)).ToArray();
        var perturbations = Simulations.Perturbation.GenerateVolatilityPerturbations(fwd, Volatilities, upBump, downBump, bumpRelative, bumpType, calcGamma);
        dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      }
      return dataTable ?? new DataTable();
    }

    /// <summary>
    ///   Calculate the the forward price (could be inflation, commodity price, stock price, etc.) factor loading sensitivities for CVA, DVA, EEs and NEEs
    /// </summary>
    /// <param name="upBump">Up bump size</param>
    /// <param name="downBump">Down bump size</param>
    /// <param name="bumpRelative">Bump sizes are relative rather than absloute</param>
    ///<param name="bumpType">Bump type</param>
    /// <param name="calcGamma">Calculate gamma if true</param>
    ///<param name="dataTable">Data table</param>
    /// <returns>Datatable of results</returns>
    public DataTable ReferenceFactorsSensitivities(double[] upBump, double[] downBump,
                                                   bool bumpRelative, BumpType bumpType, bool calcGamma,
                                                   DataTable dataTable)
    {
      if (ReferenceCurves != null && ReferenceCurves.Any())
      {
        var fwd = ReferenceCurves.GetForwardBased(Volatilities, FactorLoadings).Cast<object>().Union(
          ReferenceCurves.GetSpotBased(Volatilities, FactorLoadings).Cast<IForwardPriceCurve>().Select(p => p.Spot)).ToArray();
        var perturbations = Simulations.Perturbation.GenerateFactorPerturbations(fwd, FactorLoadings, upBump, downBump,
                                                                                 bumpRelative, bumpType, calcGamma);
        dataTable = GenerateSensitivitiesTable(perturbations, dataTable);
      }
      return dataTable ?? new DataTable();
    }

    #endregion

    #endregion

	  private Dt[] _exposureDts; 
  }

  /// <summary>
  /// Utilities
  /// </summary>
  public static class LeastSquaresMonteCarloCcrUtils
  {
    #region Methods

    private static IEnumerable<Dt> EnumerateSchedule(Schedule schedule)
    {
      for (int i = 0; i < schedule.Count; ++i)
        yield return schedule.GetPaymentDate(i);
    }

    private static void GetDefaultExerciseDates(this ExerciseEvaluator exerciseEvaluator, IEnumerable<ICashflowNode> underlierCashflow)
    {
      if ((exerciseEvaluator.ExerciseDates != null) && (exerciseEvaluator.ExerciseDates.Any()))
        return;
      if (underlierCashflow != null)
      {
        exerciseEvaluator.ExerciseDates = underlierCashflow.Select(cf => cf.PayDt).Distinct().OrderBy(dt => dt).ToList();
        return;
      }
      var cashflowEvaluator = exerciseEvaluator as CashflowExerciseEvaluator;
      if (cashflowEvaluator != null)
      {
        exerciseEvaluator.ExerciseDates = exerciseEvaluator.Cashflow.Select(cf => cf.PayDt).Distinct().OrderBy(dt => dt).ToList();
        return;
      }
      var pricerEvaluator = exerciseEvaluator as CcrPricerExerciseEvaluator;
      if (pricerEvaluator != null)
        exerciseEvaluator.ExerciseDates = GetDefaultExerciseDates(pricerEvaluator.Product);
    }

    private static IEnumerable<Dt> GetDefaultExerciseDates(this IProduct product)
    {
      var swap = product as Swap;
      if (swap != null)
        return
          EnumerateSchedule(swap.ReceiverLeg.Schedule).Concat(EnumerateSchedule(swap.PayerLeg.Schedule)).Distinct().OrderBy(dt => dt).
            ToList();
      var p = product as ProductWithSchedule;
      if (p != null)
        return EnumerateSchedule(p.Schedule).Distinct().OrderBy(dt => dt).ToList();
      throw new ArgumentException("Cannot generate default exercise schedule");
    }

    #endregion

    #region ExerciseEvaluator

    [Serializable]
    private class CcrPricerExerciseEvaluator : ExerciseEvaluator
    {
      public CcrPricerExerciseEvaluator(IPricer pricer, IEnumerable<Dt> exerciseDates, Func<Dt, double> exercisePrice, bool cashSettled)
        : base(exerciseDates, cashSettled, pricer.Product.Maturity)
      {
        Product = pricer.Product;
        _exercisePrice = exercisePrice;
        _pricer = CcrPricer.Get(pricer);

      }

      public CcrPricerExerciseEvaluator(PricerExerciseEvaluator evaluator)
        : this(evaluator.Underlier, evaluator.ExerciseDates, evaluator.ExercisePrice, evaluator.CashSettled)
      {}

      public override double Value(Dt date)
      {
        if (_pricer == null)
          return 0.0;
        if (_current == date)
          return _cache;

        _current = date;
        _cache = _pricer.FastPv(date);
        return _cache;
      }

      public override void Reset()
      {
        _current = Dt.Empty;
        _cache = 0.0;
      }

      public override double Price(Dt date)
      {
        if (_exercisePrice == null)
          return 0.0;
        return _exercisePrice(date);
      }

      public IProduct Product { get; private set; }

      [OnSerializing]
      void WrapDelegates(StreamingContext context)
      {
        _exercisePrice = _exercisePrice.WrapSerializableDelegate();
      }

      [OnSerialized, OnDeserialized]
      void UnwrapDelegates(StreamingContext context)
      {
        _exercisePrice = _exercisePrice.UnwrapSerializableDelegate();
      }

      private readonly CcrPricer _pricer;
      private Func<Dt, double> _exercisePrice; 
      private Dt _current;
      private double _cache;
    }

    [Serializable]
    private class CashflowExerciseEvaluator : ExerciseEvaluator
    {
      public CashflowExerciseEvaluator(IEnumerable<ICashflowNode> cashflow, IEnumerable<Dt> exerciseDts, Func<Dt, double> exercisePrice, bool cashSettled)
        : base(cashflow, exerciseDts, cashSettled)
      {
        _exercisePrice = exercisePrice;
      }

      public override double Price(Dt date)
      {
        if (_exercisePrice == null)
          return 0.0;
        return _exercisePrice(date);
      }

      [OnSerializing]
      void WrapDelegates(StreamingContext context)
      {
        _exercisePrice = _exercisePrice.WrapSerializableDelegate();
      }

      [OnSerialized, OnDeserialized]
      void UnwrapDelegates(StreamingContext context)
      {
        _exercisePrice = _exercisePrice.UnwrapSerializableDelegate();
      }

      private Func<Dt, double> _exercisePrice; 
    }

    [Serializable]
    private class DeterministicExerciseEvaluator : ExerciseEvaluator
    {
      public DeterministicExerciseEvaluator(IEnumerable<Dt> exerciseDts, Func<Dt, double> exerciseValue, Func<Dt, double> exercisePrice)
        : base(exerciseDts, true, Dt.Empty)
      {
        _exercisePrice = exercisePrice;
        _exerciseValue = exerciseValue;
      }

      public override double Value(Dt date)
      {
        if (_exerciseValue == null)
          return 0.0;
        return _exerciseValue(date);
      }

      public override double Price(Dt date)
      {
        if (_exercisePrice == null)
          return 0.0;
        return _exercisePrice(date);
      }

      [OnSerializing]
      void WrapDelegates(StreamingContext context)
      {
        _exercisePrice = _exercisePrice.WrapSerializableDelegate();
        _exerciseValue = _exerciseValue.WrapSerializableDelegate();
      }

      [OnSerialized, OnDeserialized]
      void UnwrapDelegates(StreamingContext context)
      {
        _exercisePrice = _exercisePrice.UnwrapSerializableDelegate();
        _exerciseValue = _exerciseValue.UnwrapSerializableDelegate();
      }

      Func<Dt, double> _exerciseValue;
      Func<Dt, double>_exercisePrice;
    }

    #endregion

    #region Factory

    /// <summary>
    /// Transform to fast CCR evaluator, if possible.
    /// </summary>
    /// <param name="exerciseEvaluator">evaluator</param>
    /// <param name="underlierCashflow">Underlying cashflows</param>
    /// <returns>If available, speed optimized evaluator</returns>
    internal static ExerciseEvaluator ToCcrExerciseEvaluator(this ExerciseEvaluator exerciseEvaluator, IEnumerable<ICashflowNode> underlierCashflow)
    {
      if (exerciseEvaluator == null)
        return null;
      var pricerExerciseClaim = exerciseEvaluator as PricerExerciseEvaluator;
      if (pricerExerciseClaim != null)
        exerciseEvaluator = new CcrPricerExerciseEvaluator(pricerExerciseClaim);
      if ((exerciseEvaluator.ExerciseDates == null) || !exerciseEvaluator.ExerciseDates.Any())
        exerciseEvaluator.GetDefaultExerciseDates(underlierCashflow);
      return !exerciseEvaluator.ExerciseDates.Any() ? null : exerciseEvaluator;
    }


    /// <summary>
    /// Create default exercise evaluator.
    /// <list type="bullet"> 
    /// <item>
    /// <description>IPricer : the exercise value is the IPricer.Pv at exercise date.</description>
    /// </item>
    /// <item>
    /// <description>IList{ICashflowNode} : the exercise value is the Pv of the cashflows paid after exercise date and is, itself, computed by Least Squares MC. </description>
    /// </item>
    /// <item>
    /// <description>System.Func{Dt,double} : the exercise value is Func(exerciseDate)</description>
    /// </item>
    /// </list> 
    /// </summary>
    /// <param name="exerciseEvaluator">evaluator object</param>
    /// <param name="exercisePrice">Exercise price</param>
    /// <param name="exerciseDates">Exercise dates</param>
    /// <param name="cashSettled">Settlement type</param>
    /// <returns>Exercise evaluator</returns>
    public static ExerciseEvaluator ExerciseEvaluatorFactory(object exerciseEvaluator,  Func<Dt, double> exercisePrice, IEnumerable<Dt> exerciseDates, bool cashSettled)
    {
      if (exerciseEvaluator == null)
        return null;
      var pricer = exerciseEvaluator as IPricer;
      if (pricer != null)
        return new CcrPricerExerciseEvaluator(pricer, exerciseDates, exercisePrice, cashSettled);
      var cashflow = exerciseEvaluator as IList<ICashflowNode>;
      if (cashflow != null)
      {
        return new CashflowExerciseEvaluator(cashflow, exerciseDates, exercisePrice, cashSettled);
      }
      var fn = exerciseEvaluator as Func<Dt, double>;
      if (fn != null)
        return new DeterministicExerciseEvaluator(exerciseDates, fn, exercisePrice);
      return (ExerciseEvaluator)exerciseEvaluator;
    }

    #endregion
  }
}