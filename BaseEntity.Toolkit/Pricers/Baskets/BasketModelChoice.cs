/*
 * BasketModelChoice.cs
 *
 *  -2008. All rights reserved.
 *
 * $Id$
 *
 */
using System;
using System.Collections.Generic;
using System.Text;

namespace BaseEntity.Toolkit.Pricers.Baskets
{
  #region Basket Model Types
  /// <summary>
  ///  Basket type used to calibrate base correlation
  /// </summary>
  public enum BasketModelType
  {
    /// <summary>
    ///   Use default model (semi-analytic heterogeneous model)
    /// </summary>
    /// <remarks>
    ///   This model does not check refinance information and therefore it does
    ///   not work with LCDOs.
    /// </remarks>
    Default = 0,

    /// <summary>
    ///   Use large homogeneous pool model
    /// </summary>
    LargePool = 1,

    /// <summary>
    ///   Use homogeneous binomial distribution model
    /// </summary>
    Uniform = 2,

    /// <summary>
    ///   Use semi-analytic model
    /// </summary>
    /// <remarks>
    ///   This model checks refinance information in the survival curves and when they present,
    ///   it uses them in calibration based on the LCDX tranches model with proportional probabilities
    ///   (the old model).  Therefore it works with LCDX tranches.
    /// </remarks>
    SemiAnalytic = 3,

    /// <summary>
    ///   Use general Monte Carlo model
    /// </summary>
    MonteCarlo = 4,

    /// <summary>
    ///   Probability of cancellation is proportional to conditional default probability.
    /// </summary>
    LCDOProportional = 5,

    /// <summary>
    ///   The events of cancellation and default are generated by common signals.
    /// </summary>
    LCDOCommonSignal = 6,
  };
  #endregion Basket model Types

  #region Basket Model Choces
  /// <summary>
  ///   A struct representing basket model choice.
  /// </summary>
  [Serializable]
  public struct BasketModelChoice
  {
    /// <summary>Equal to operator</summary>
    public static bool operator ==(BasketModelChoice c1, BasketModelChoice c2)
    { return c1.choice_ == c2.choice_; }

    /// <summary>Not equal to operator</summary>
    public static bool operator !=(BasketModelChoice c1, BasketModelChoice c2)
    { return c1.choice_ != c2.choice_; }

    /// <summary>
    /// Returns the hash code for this instance.
    /// </summary>
    /// <returns>
    /// A 32-bit signed integer that is the hash code for this instance.
    /// </returns>
    public override int GetHashCode()
    {
      return choice_.GetHashCode();
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="obj"></param>
    /// <returns></returns>
    public override bool Equals(object obj)
    {
      if (!(obj is BasketModelChoice))
        return false;
      return this.choice_ == ((BasketModelChoice)obj).choice_;
    }

    /// <summary>
    ///   Whether to use correlated recovery model
    ///   (currently only works with semi-analytic model).
    ///   <preliminary/>
    /// </summary>
    /// <exclude />
    public bool WithCorrelatedRecovery
    {
      get { return (qcrbit & choice_) != 0; }
      set
      {
        if (value)
        {
          choice_ |= qcrbit;
          if ((choice_ & qcrmask) == 0)
            choice_ |= (int)RecoveryCorrelationType.ZeroOne;
        }
        else
          choice_ &= ~qcrbit;
        return;
      }
    }

    /// <summary>
    ///   Correlated recovery model to use.
    ///   <preliminary/>
    /// </summary>
    /// <exclude/>
    public RecoveryCorrelationType QCRModel
    {
      get
      {
        return (qcrbit & choice_) != 0
          ? (RecoveryCorrelationType)(choice_ & qcrmask)
          : RecoveryCorrelationType.None;
      }
      set
      {
        value = (RecoveryCorrelationType)((int)value & qcrmask);
        if (value != RecoveryCorrelationType.None)
        {
          choice_ = ((int)value) | (choice_ & ~qcrmask);
          choice_ |= qcrbit;
        }
        else
          choice_ &= ~qcrbit;
      }
    }

    /// <summary>
    ///   LCDX Tranche model to use.
    ///   <preliminary/>
    /// </summary>
    /// <exclude/>
    public BasketModelType BasketModel
    {
      get
      {
        return (BasketModelType)
          ((choice_ & 0xF0) >> 4);
      }
      set
      {
        choice_ = (((int)value & 0xF) << 4)
          | (choice_ & ~0xF0);
      }
    }

    /// <summary>
    ///   Whether to use correlations beyond 1.
    /// </summary>
    internal bool ExtendedCorreltion
    {
      get { return (extbit & choice_) != 0; }
      set
      {
        if (value) choice_ |= extbit;
        else choice_ &= ~extbit;
      }
    }

    internal int ToInt32()
    {
      return choice_;
    }

    private int choice_;
    const int extbit = 0x08;
    const int qcrbit = 0x04;
    const int qcrmask = 0x03;
  }
  #endregion Basket Model Choices
  
  #region RecoveryCorrelationModel

  /// <summary>
  ///   Recovery correlation model
  /// </summary>
  [Serializable]
  internal struct RecoveryCorrelationModel
  {
    /// <summary>
    ///  The model choice.
    /// </summary>
    public BasketModelChoice ModelChoice;
    /// <summary>
    ///  Recovery boundary.
    /// </summary>
    public double MaxRecovery, MinRecovery;

    /// <summary>
    ///  The default Recovery correlation model.
    /// </summary>
    public static RecoveryCorrelationModel Default
      = new RecoveryCorrelationModel
      {
        ModelChoice = new BasketModelChoice(),
        MaxRecovery = 1.0,
        MinRecovery = 0.0,
      };

    internal void SetExtendedCorrelation(bool value)
    {
      ModelChoice.ExtendedCorreltion = value;
    }

    internal void SetWithCorrelatedRecovery(bool value)
    {
      ModelChoice.WithCorrelatedRecovery = value;
    }
  }

  #endregion
}
