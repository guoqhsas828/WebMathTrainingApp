// /*
//  *  -2012. All rights reserved.
//  */

using System;
using System.Collections;
using System.Linq;
using log4net;
using BaseEntity.Shared;
using BaseEntity.Toolkit.Base;
using BaseEntity.Toolkit.Cashflows;
using BaseEntity.Toolkit.Curves;
using BaseEntity.Toolkit.Products;

namespace BaseEntity.Toolkit.Pricers
{
  /// <summary>
  /// Pricer for FxSwap product.
  /// </summary>
  /// <summary>
  /// <para>Price a <see cref="BaseEntity.Toolkit.Products.FxSwap">Fx Swap</see> using a fx
  /// forward curve and interest rate discount curve.</para>
  /// <inheritdoc cref="BaseEntity.Toolkit.Products.FxSwap" />
  /// </summary>
  /// <seealso cref="BaseEntity.Toolkit.Products.FxSwap">Fx Swap Product</seealso>
  /// <seealso cref="BaseEntity.Toolkit.Curves.FxCurve">Fx Curve</seealso>
  [Serializable]
  public class FxSwapPricer : PricerBase, IPricer
  {
    private static readonly ILog logger = LogManager.GetLogger(typeof(FxSwapPricer));

    #region Constructors

    /// <summary>
    /// Default constructor
    /// </summary>
    public FxSwapPricer()
      : base(null)
    {}

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="fwd">FxSwap product</param>
    /// <param name="asOf">Pricing as-of date</param>
    /// <param name="settle">Pricing settlement date</param>
    /// <param name="notional">Notional (amount received in receive currency)</param>
    /// <param name="valuationCcy">Currency to value trade in (or none for fx pay currency)</param>
    /// <param name="discountCurve">Discount curve for valuation currency (or null to take from fx curve calibration)</param>
    /// <param name="receiveCcyFxCurve">Fx curve translating fwd.Ccy (receive Ccy) to valuationCcy (ignored if valuation ccy fx receive currency)</param>
    /// <param name="payCcyFxCurve">Fx curve translating fwd.PayCcy to valuationCcy (ignored if valuation ccy fx pay currency)</param>
    public FxSwapPricer(FxSwap fwd, Dt asOf, Dt settle, double notional, Currency valuationCcy,
                        DiscountCurve discountCurve, FxCurve receiveCcyFxCurve, FxCurve payCcyFxCurve)
      : base(fwd, asOf, settle)
    {
      Notional = notional;
      _valuationCurrency = (valuationCcy != Currency.None) ? valuationCcy : receiveCcyFxCurve.Ccy1;
      DiscountCurve = discountCurve ?? FxUtil.DiscountCurve(valuationCcy, receiveCcyFxCurve, payCcyFxCurve);
      ReceiveCcyFxCurve = (valuationCcy != fwd.Ccy) ? receiveCcyFxCurve : null;
      PayCcyFxCurve = (valuationCcy != fwd.NearPayCcy) ? payCcyFxCurve : null;
    }

    /// <summary>
    /// Shallow copy 
    /// </summary>
    /// <returns>A new fx swap pricer object.</returns>
    public override object Clone()
    {
      return new FxSwapPricer(FxSwap, AsOf, Settle, Notional, ValuationCurrency, DiscountCurve, ReceiveCcyFxCurve,
                              PayCcyFxCurve);
    }

    #endregion

    #region Methods

    /// <summary>
    ///   Validate pricer inputs
    /// </summary>
    /// <param name="errors">Error list </param>
    /// <remarks>
    ///   This tests only relationships between fields of the pricer that
    ///   cannot be validated in the property methods.
    /// </remarks>
    public override void Validate(ArrayList errors)
    {
      var swap = (FxSwap)Product;
      base.Validate(errors);
      if (DiscountCurve == null)
        InvalidValue.AddError(errors, this, "DiscountCurve", String.Format("Invalid discount curve. Cannot be null"));
      if (PayCcyFxCurve == null && ReceiveCcyFxCurve == null)
        InvalidValue.AddError(errors, this, "FxCurve", String.Format("Both fx curves cannot be null"));
      return;
    }

    /// <summary>
    /// Get the payment schedule for valuation (PV) calculation: a detailed representation of payments
    /// <param name="ps"></param>
    /// <param name="from">As of date</param>
    /// <returns>payments generated by the product</returns>
    /// <remarks>Payments generated based on a purchase of 1 unit of Ccy (Receive Ccy) with NearFxRate units of Pay Ccy</remarks>
    /// </summary>
    public override PaymentSchedule GetPaymentSchedule(PaymentSchedule ps, Dt @from)
    {
      PaymentSchedule pmtSchedule = ps ?? new PaymentSchedule();

      // -- near
      if (FxSwap.NearValueDate > from)
      {
        // buy (receive +ve)
        pmtSchedule.AddPayment(new BasicPayment(FxSwap.NearValueDate, +Math.Sign(Notional)*FxSwap.NearReceiveAmount, FxSwap.Ccy) {FXCurve = ReceiveCcyFxCurve});
        // sell (pay -ve)
        pmtSchedule.AddPayment(new BasicPayment(FxSwap.NearValueDate, -Math.Sign(Notional) * FxSwap.NearPayAmount,
                                                FxSwap.NearPayCcy) {FXCurve = PayCcyFxCurve});
      }

      // -- far
      if (FxSwap.FarValueDate > from)
      {
        // sell back (pay -ve)
        pmtSchedule.AddPayment(new BasicPayment(FxSwap.FarValueDate, -Math.Sign(Notional)*FxSwap.FarPayAmount, FxSwap.Ccy) {FXCurve = ReceiveCcyFxCurve});
        // buy back (receive +ve)
        pmtSchedule.AddPayment(new BasicPayment(FxSwap.FarValueDate, +Math.Sign(Notional) * FxSwap.FarReceiveAmount,
                                                FxSwap.NearPayCcy) {FXCurve = PayCcyFxCurve});
      }
      return pmtSchedule;
    }

    /// <summary>
    /// Present value in valuation currency
    /// </summary>
    public override double ProductPv()
    {
      double pv = 0.0;
      foreach (Payment p in GetPaymentSchedule(null, Settle))
      {
        pv += p.DomesticAmount * DiscountCurve.DiscountFactor(p.PayDt);
      }
      return pv * Notional;
    }

    /// <summary>
    /// Return spot fx rate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Spot fx rate</returns>
    public double SpotFxRate(Currency ccy1, Currency ccy2)
    {
      return FxUtil.SpotFxRate(ccy1, ccy2, PayCcyFxCurve, ReceiveCcyFxCurve);
    }

    /// <summary>
    /// Forward fx rate on NearValueDate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Forward fx rate at NearValueDate</returns>
    public double NearForwardFxRate(Currency ccy1, Currency ccy2)
    {
      return FxUtil.ForwardFxRate(FxSwap.NearValueDate, ccy1, ccy2, PayCcyFxCurve, ReceiveCcyFxCurve);
    }

    /// <summary>
    /// Forward fx points on NearValueDate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Forward fx points at NearValueDate</returns>
    public double NearForwardFxPoints(Currency ccy1, Currency ccy2)
    {
      return (NearForwardFxRate(ccy1, ccy2) - SpotFxRate(ccy1, ccy2)) * 10000.0;
    }

    /// <summary>
    /// Forward fx rate on FarValueDate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Forward fx rate at FarValueDate</returns>
    public double FarForwardFxRate(Currency ccy1, Currency ccy2)
    {
      return FxUtil.ForwardFxRate(FxSwap.FarValueDate, ccy1, ccy2, PayCcyFxCurve, ReceiveCcyFxCurve);
    }

    /// <summary>
    /// Forward fx points on FarValueDate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Forward fx points at FarValueDate</returns>
    public double FarForwardFxPoints(Currency ccy1, Currency ccy2)
    {
      return (FarForwardFxRate(ccy1, ccy2) - SpotFxRate(ccy1, ccy2)) * 10000.0;
    }

    /// <summary>
    /// Near amount paid in pay currency
    /// </summary>
    /// <returns>Amount paid in pay currency</returns>
    public double NearPayAmount()
    {
      return Notional * FxSwap.NearPayAmount;
    }

    /// <summary>
    /// Near amount received in receive currency
    /// </summary>
    /// <returns>Amount received in receive currency</returns>
    public double NearReceiveAmount()
    {
      return Notional * FxSwap.NearReceiveAmount;
    }

    /// <summary>
    /// Far amount paid in near receive currency
    /// </summary>
    /// <returns>Amount paid in pay currency</returns>
    public double FarPayAmount()
    {
      return FxSwap.FarPayAmount * Notional;
    }

    /// <summary>
    /// Far amount received in near pay currency
    /// </summary>
    /// <returns>Amount received in near pay currency</returns>
    public double FarReceiveAmount()
    {
      return FxSwap.FarReceiveAmount * Notional;
    }

    /// <summary>
    /// Valuation currency discount factor from NearValueDate to pricing date
    /// </summary>
    /// <returns>Valuation currency discount factor from NearValueDate</returns>
    public double NearDiscountFactor()
    {
      return DiscountCurve.DiscountFactor(FxSwap.NearValueDate);
    }

    /// <summary>
    /// Valuation currency discount factor from FarValueDate to pricing date
    /// </summary>
    /// <returns>Valuation currency discount factor from FarValueDate</returns>
    public double FarDiscountFactor()
    {
      return DiscountCurve.DiscountFactor(FxSwap.FarValueDate);
    }

    #endregion Methods

    #region Properties

    /// <summary>
    /// Payment pricer
    /// </summary>
    public override IPricer PaymentPricer
    {
      get
      {
        if (Payment != null)
        {
          if (paymentPricer_ == null)
            paymentPricer_ = BuildPaymentPricer(Payment, DiscountCurve);
        }
        return paymentPricer_;
      }
    }

    /// <summary>
    ///   Swap leg Product
    /// </summary>
    public FxSwap FxSwap
    {
      get { return (FxSwap)Product; }
    }

    /// <summary>
    /// Accessor for the discount curve. 
    /// </summary>
    public DiscountCurve DiscountCurve { get; set; }

    /// <summary>
    /// Currency of the Pv calculation
    /// </summary>
    public override Currency ValuationCurrency
    {
      get { return _valuationCurrency; }
    }

    /// <summary>
    /// FxCurve from pay currency to valuation currency (or null if pay currency is valuation currency)
    /// </summary>
    public FxCurve PayCcyFxCurve { get; set; }

    /// <summary>
    /// FxCurve from receive currency to valuation currency (or null if receive currency is valuation currency)
    /// </summary>
    public FxCurve ReceiveCcyFxCurve { get; set; }

    #endregion

    #region PropertyGetter Properties

    /// <summary>
    /// Return array of FxCurves used by this pricer
    /// </summary>
    public FxCurve[] FxCurves
    {
      get { return new[] {ReceiveCcyFxCurve, PayCcyFxCurve}.Where(f => f != null).ToArray(); }
    }

    /// <summary>
    /// Accessor for the fx basis curve. This is only used for internal purposes to compute sensitivities
    /// </summary>
    public CalibratedCurve[] BasisAdjustments
    {
      get
      {
        return
          (from fx in new[] {ReceiveCcyFxCurve, PayCcyFxCurve} where fx != null where !fx.IsSupplied select fx.BasisCurve).Cast
            <CalibratedCurve>().ToArray();
      }
    }

    #endregion Properties

    #region Data
    private readonly Currency _valuationCurrency;
    #endregion Data
  }
}