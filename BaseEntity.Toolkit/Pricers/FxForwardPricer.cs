/*
 *  -2012. All rights reserved.
 */
using System;
using System.Linq;
using BaseEntity.Toolkit.Cashflows;
using BaseEntity.Toolkit.Base;
using BaseEntity.Toolkit.Curves;
using BaseEntity.Toolkit.Products;
using BaseEntity.Shared;

namespace BaseEntity.Toolkit.Pricers
{
  /// <summary>
  /// Price a <see cref="BaseEntity.Toolkit.Products.FxForward">Fx Forward</see> using a fx
  /// forward curve and interest rate discount curve.
  /// </summary>
  /// <remarks>
  /// <inheritdoc cref="BaseEntity.Toolkit.Products.FxForward" />
  /// </remarks>
  /// <seealso cref="BaseEntity.Toolkit.Products.FxForward">Fx Forward Product</seealso>
  /// <seealso cref="BaseEntity.Toolkit.Curves.FxCurve">Fx Curve</seealso>
  [Serializable]
  public class FxForwardPricer : PricerBase, IPricer
  {
    private readonly static log4net.ILog logger = log4net.LogManager.GetLogger(typeof(FxForwardPricer));

    #region Constructors

    /// <summary>
    /// Construct a pricer for an fx forward
    /// </summary>
    /// <param name="fwd">Fx Forward</param>
    /// <param name="asOf">Pricing (asOf) date</param>
    /// <param name="settle">Spot settlement date</param>
    /// <param name="notional">Notional (amount received in receive currency)</param>
    /// <param name="valuationCcy">Currency to value trade in (or none for fx pay currency)</param>
    /// <param name="discountCurve">Discount curve for valuation currency (or null to take from fx curve calibration)</param>
    /// <param name="receiveCcyFxCurve">Fx curve translating fwd.Ccy (receive Ccy) to valuationCcy (ignored if valuation ccy fx receive currency)</param>
    /// <param name="payCcyFxCurve">Fx curve translating fwd.PayCcy to valuationCcy (ignored if valuation ccy fx pay currency)</param>
    public FxForwardPricer(FxForward fwd, Dt asOf, Dt settle, double notional, Currency valuationCcy, DiscountCurve discountCurve, FxCurve receiveCcyFxCurve, FxCurve payCcyFxCurve)
      : base(fwd, asOf, settle)
    {
      Notional = notional;
      _valuationCurrency = valuationCcy;
      DiscountCurve = discountCurve ?? FxUtil.DiscountCurve(valuationCcy, receiveCcyFxCurve, payCcyFxCurve);
      ReceiveCcyFxCurve = (valuationCcy != fwd.Ccy) ? receiveCcyFxCurve : null;
      PayCcyFxCurve = (valuationCcy != fwd.PayCcy) ? payCcyFxCurve : null;
    }

    /// <summary>
    /// Shallow copy 
    /// </summary>
    /// <returns>A fx forward pricer object.</returns>
    public override object Clone()
    {
      return new FxForwardPricer(FxForward, AsOf, Settle, Notional, ValuationCurrency, DiscountCurve, ReceiveCcyFxCurve, PayCcyFxCurve);
    }

    #endregion Constructors

    #region Methods
    
    /// <summary>
    ///   Validate pricer inputs
    /// </summary>
    /// <param name="errors">Error list</param>
    /// <remarks>
    ///   This tests only relationships between fields of the pricer that
    ///   cannot be validated in the property methods.
    /// </remarks>
    public override void Validate(System.Collections.ArrayList errors)
    {
      base.Validate(errors);
      if (DiscountCurve == null)
        InvalidValue.AddError(errors, this, "DiscountCurve", String.Format("Invalid discount curve. Must be specified or able to be implied from currency and fx calibration"));
      if (FxForward.Ccy != ValuationCurrency && ReceiveCcyFxCurve == null)
        InvalidValue.AddError(errors, this, "ReceiveCcyFxCurve", String.Format("Fx curve between [{0}]/[{1}] is required, cannot be null",
          FxForward.Ccy, ValuationCurrency));
      if (FxForward.PayCcy != ValuationCurrency && PayCcyFxCurve == null)
        InvalidValue.AddError(errors, this, "ReceiveCcyFxCurve", String.Format("Fx curve between [{0}]/[{1}] is required, cannot be null",
          FxForward.PayCcy, ValuationCurrency));
      return;
    }

    /// <summary>
    /// Get the payment schedule for valuation (PV) calculation: a detailed representation of payments
    /// </summary>
    /// <remarks>
    /// Payments generated based on a purchase of 1 unit of Ccy (Receive Ccy) with FxRate units of Pay Ccy
    /// </remarks>
    /// <param name="ps">Payment schedule to fill or null for new schedule</param>
    /// <param name="from">Date to generate Payment Schedule from</param>
    /// <returns>payments generated by the product</returns>
    public override PaymentSchedule GetPaymentSchedule(PaymentSchedule ps, Dt from)
    {
      PaymentSchedule pmtSchedule = ps ?? new PaymentSchedule();

      if (FxForward.ValuationDate > from)
      {
        // buy (receive +ve)
        pmtSchedule.AddPayment(new BasicPayment(FxForward.ValuationDate, 1.0, FxForward.Ccy)
                                 {
                                   FXCurve = ReceiveCcyFxCurve
                                 });
        // sell (pay -ve)
        pmtSchedule.AddPayment(new BasicPayment(FxForward.ValuationDate, -1.0*FxForward.FxRate, FxForward.PayCcy)
                                 {
                                   FXCurve = PayCcyFxCurve
                                 });
      }
      return pmtSchedule;
    }

    /// <summary>
    /// Present value in valuation currency
    /// </summary>
    public override double ProductPv()
    {
      double pv = 0.0;
      foreach (Payment p in GetPaymentSchedule(null, Settle))
      {
        pv += p.DomesticAmount * DiscountCurve.DiscountFactor(p.PayDt);
      }
      return pv * Notional;
    }

    /// <summary>
    /// Return spot fx rate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Spot fx rate</returns>
    public double SpotFxRate(Currency ccy1, Currency ccy2)
    {
      return FxUtil.SpotFxRate(ccy1, ccy2, PayCcyFxCurve, ReceiveCcyFxCurve);
    }

    /// <summary>
    /// Return forward fx rate on ValueDate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Forward fx rate at ValueDate</returns>
    public double ForwardFxRate(Currency ccy1, Currency ccy2)
    {
      return FxUtil.ForwardFxRate(FxForward.ValuationDate, ccy1, ccy2, PayCcyFxCurve, ReceiveCcyFxCurve);
    }

    /// <summary>
    /// Return forward fx points on ValueDate
    /// </summary>
    /// <param name="ccy1">Base (domestic/base/unit/transaction/source/to) currency</param>
    /// <param name="ccy2">Quoting (foreign/quote/price/payment/destination/from) currency</param>
    /// <returns>Forward fx points at ValueDate</returns>
    public double ForwardFxPoints(Currency ccy1, Currency ccy2)
    {
      return (ForwardFxRate(ccy1, ccy2) - SpotFxRate(ccy1, ccy2))*10000.0;
    }

    /// <summary>
    /// Amount paid in pay currency
    /// </summary>
    /// <returns>Amount paid in pay currency</returns>
    public double PayAmount()
    {
      return Notional * FxForward.FxRate;
    }

    /// <summary>
    /// Amount received in receive currency
    /// </summary>
    /// <returns>Amount received in receive currency</returns>
    public double ReceiveAmount()
    {
      return Notional;
    }

    /// <summary>
    /// Valuation currency discount factor from ValueDate to pricing date
    /// </summary>
    /// <returns>Valuation currency discount factor from ValueDate</returns>
    public double DiscountFactor()
    {
      return DiscountCurve.DiscountFactor(FxForward.ValuationDate);
    }

    #endregion Methods

    #region Properties

    /// <summary>
    /// FxCurve from pay currency to valuation currency (or null if pay currency is valuation currency)
    /// </summary>
    public FxCurve PayCcyFxCurve { get; set; }

    /// <summary>
    /// FxCurve from receive currency to valuation currency (or null if receive currency is valuation currency)
    /// </summary>
    public FxCurve ReceiveCcyFxCurve { get; set; }

    /// <summary>
    /// Currency of the Pv calculation
    /// </summary>
    public override Currency ValuationCurrency
    {
      get { return (_valuationCurrency != Currency.None) ? _valuationCurrency : ReceiveCcyFxCurve.Ccy1; }
    }

    /// <summary>
    /// Discount curve of valuation currency
    /// </summary>
    public DiscountCurve DiscountCurve { get; set; }

    /// <summary>
    /// FX Forward Product
    /// </summary>
    public FxForward FxForward
    {
      get { return (FxForward)Product; }
    }

    #region IPricer

    /// <summary>
    /// Payment pricer
    /// </summary>
    public override IPricer PaymentPricer
    {
      get
      {
        if (Payment != null)
        {
          if (paymentPricer_ == null)
            paymentPricer_ = BuildPaymentPricer(Payment, DiscountCurve);
        }
        return paymentPricer_;
      }
    }

    #endregion IPricer

    #endregion

    #region PropertyGetter Properties

    /// <summary>
    /// Return array of FxCurves used by this pricer
    /// </summary>
    public FxCurve[] FxCurves
    {
      get
      {
        return new[] { ReceiveCcyFxCurve, PayCcyFxCurve }.Where(f => f != null).ToArray();
      }
    }

    /// <summary>
    /// Accessor for the fx basis curve. This is only used for internal purposes to compute sensitivities
    /// </summary>
    public CalibratedCurve[] BasisAdjustments
    {
      get
      {
        return (from fx in new[] { ReceiveCcyFxCurve, PayCcyFxCurve } where fx != null where !fx.IsSupplied select fx.BasisCurve).Cast<CalibratedCurve>().ToArray();
      }
    }

    #endregion

    #region Data

    private readonly Currency _valuationCurrency;

    #endregion
  }
}
