/*
 * Copyright (c)    2012-15. All rights reserved.
 */

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using BaseEntity.Shared;
using FieldValue = System.Collections.Generic.KeyValuePair<string, object>;

namespace BaseEntity.Toolkit.Base.Serialization
{
  using Utility = SimpleXmlSerializationUtility;

  /// <summary>
  ///   Simple utility to serialize/deserialize object in binary format,
  ///   supporting serialization of in-memory assemblies and anonymous
  ///   types generated by scripts and compiler.
  /// </summary>
  public static class BinarySerialization
  {

    /// <summary>
    ///   Save the specified object to a file in binary format.
    /// </summary>
    /// <param name="data">The data to serialize</param>
    /// <param name="filePath">The file to store the data</param>
    public static void SaveBinary(this object data, string filePath)
    {
      using (var stream = File.OpenWrite(filePath))
      {
        Serialize(data, stream);
      }
    }

    /// <summary>
    ///   Load data from the specified file in binary format.
    /// </summary>
    /// <param name="filePath">The file containing the data</param>
    /// <returns>The loaded object</returns>
    public static object LoadBinary(this string filePath)
    {
      using (var stream = File.OpenRead(filePath))
      {
        return Deserialize(stream);
      }
    }

    /// <summary>
    ///   Save the specified object to a file in binary format.
    /// </summary>
    /// <param name="data">The data to serialize</param>
    /// <param name="stream">The stream to store the data</param>
    public static void Serialize(this object data, Stream stream)
    {
        new BinaryFormatter(null, new StreamingContext(
          StreamingContextStates.File, new FastCloningContext()))
          .Serialize(stream, data);
    }

    /// <summary>
    ///   Load data from the specified file in binary format.
    /// </summary>
    /// <param name="stream">The stream containing the data</param>
    /// <returns>The loaded object</returns>
    public static object Deserialize(this Stream stream)
    {
      return new BinaryFormatter(null, new StreamingContext(
        StreamingContextStates.File, new FastCloningContext()))
        .Deserialize(stream);
    }

    /// <summary>
    ///   A helper to wrap object as serializable
    /// </summary>
    /// <param name="data"></param>
    /// <param name="context"></param>
    /// <returns></returns>
    internal static object WrapSerializable(
      this object data, StreamingContext context)
    {
      return data == null ? null : TryGetMappedObject(data, context)
        ?? DoWrap(data).SetMap(data, context);
    }

    private static object DoWrap(object data)
    {
      if (data is Delegate)
        return data.WrapSerializableDelegate();
      var ass = data as Assembly;
      if (ass != null)
        return AssemblyData.Wrap(ass);
      var type = data as Type;
      if (type != null)
        return TypeData.Wrap(type);
      var method = data as MethodInfo;
      if (method != null)
        return MethodWrapper.Wrap(method);
      return SimpleObjectWrapper.Wrap(data);
    }

    /// <summary>
    ///   A helper to unwrap the object wrapped as serializable
    /// </summary>
    /// <param name="data"></param>
    /// <param name="context"></param>
    /// <returns></returns>
    internal static object UnwrapSerializable(
      this object data, StreamingContext context)
    {
      if (data == null)
        return null;
      if (data is Delegate)
        return data.UnwrapSerializableDelegate();
      var simple = data as SimpleObjectWrapper;
      if (simple != null)
        return simple.Value;
      var type = data as TypeData;
      if (type != null)
        return TypeData.Unwrap(type);
      var method = data as MethodWrapper;
      if (method != null)
        return MethodWrapper.Unwrap(method);
      var ass = data as AssemblyData;
      if (ass != null)
        return AssemblyData.Unwrap(ass);
      return data;
    }

    private static object TryGetMappedObject(
      object data, StreamingContext context)
    {
      object result;
      var map = context.Context as FastCloningContext;
      if (map != null && map.TryGetValue(data, out result))
        return result;
      return null;
    }

    private static object SetMap(this object mapped, 
      object data, StreamingContext context)
    {
      if (ReferenceEquals(data, mapped))
        return mapped;
      var map = context.Context as FastCloningContext;
      if (map != null && !map.ContainsKey(data))
        map[data] = mapped;
      return mapped;
    }

    internal static bool IsDeclaredInScript(this MemberInfo info)
    {
      return info.DeclaringType != null && AssemblyData.Find(
        info.DeclaringType.Assembly.FullName) != null;
    }
  }

  /// <summary>
  ///   Wrapped as serializable the in-memory assemblies created by scripts
  /// </summary>
  [Serializable]
  public sealed class AssemblyData
  {
    #region Instance members

    // ReSharper disable InconsistentNaming
    private string name;
    private byte[] image;
    // ReSharper restore InconsistentNaming
    [NonSerialized] private string _path;
    [NonSerialized] private Assembly _assembly;

    private Assembly GetAssembly()
    {
      if (_assembly != null)
        return _assembly;
      if (image != null)
        return (_assembly = Assembly.Load(image));
      if (_path != null)
        return (_assembly = Assembly.LoadFrom(_path));
      throw new SerializationException(String.Format(
        "Unable to load assembly: {0}", name));
    }

    private AssemblyData LoadImage()
    {
      if (image != null)
        return this;
      if (File.Exists(_path))
      {
        image = File.ReadAllBytes(_path);
        return this;
      }
      throw new FileNotFoundException(String.Format(
        "Unable to find assembly file: {0}", _path));
    }

    #endregion

    #region Static members

    // Collection of in-memory assemblies compiled from scripts.
    // Currently the assemblies are not collectible, so no weak table.
    private static readonly Dictionary<string, AssemblyData> Map
      = new Dictionary<string, AssemblyData>();

    private static AssemblyData Add(Assembly assembly)
    {
      if (assembly == null) return null;

      if (Map.TryGetValue(assembly.FullName, out var data))
        return data;

      var name = assembly.FullName;
      data = new AssemblyData
      {
        name = assembly.FullName,
        _assembly = assembly
      };
      Map.Add(name, data);
      return data;
    }

    private static void Add(AssemblyData data)
    {
      Debug.Assert(data._assembly != null);
      var ad = Add(data._assembly);
      ad.image = data.image;
      ad._path = data._path;
    }

    public static void Add(string assemblyPath, Assembly assembly)
    {
      var data = Add(assembly);
      data._path = assemblyPath;
    }

    public static bool NeedWrap(Assembly assembly)
    {
      return assembly != null && Map.ContainsKey(assembly.FullName);
    }

    public static Assembly Find(string assemblyName)
    {
      return Map.TryGetValue(assemblyName, out var data)
        ? data._assembly : null;
    }

    public static object Wrap(Assembly assembly)
    {
      if (assembly == null) return null;

      return Map.TryGetValue(assembly.FullName, out var w)
        ? (object) w.LoadImage() : assembly;
    }

    public static Assembly Unwrap(object data)
    {
      if (!(data is AssemblyData w))
        return (Assembly) data;

      var assembly = w.GetAssembly();
      Add(w);
      return assembly;
    }

    public static AssemblyData Wrap(
      Assembly assembly, SimpleXmlSerializer settings)
    {
      if (!NeedWrap(assembly)) return null;

      var tracker = settings.ReferenceTracker;
      var name = assembly.FullName;
      if (tracker.ContainsAssembly(name))
      {
        return new AssemblyData {name = name};
      }
      tracker.Add(assembly);
      if (!Map.TryGetValue(assembly.FullName, out var ad))
      {
        throw new InvalidDataException("Cache corrupted");
      }
      return ad.LoadImage();
    }

    public static Assembly Unwrap(AssemblyData data,
      SimpleXmlSerializer settings)
    {
      var tracker = settings.ReferenceTracker;
      var name = data.name;
      if (tracker.TryGetAssembly(name, out var assembly))
      {
        return assembly;
      }
      assembly = data.GetAssembly();
      tracker.Add(assembly);
      Add(data);
      return assembly;
    }

    #endregion
  }

  /// <summary>
  ///   Wrapped as serializable the types created by scripts
  /// </summary>
  [Serializable]
  internal sealed class TypeData
  {
    #region Instance members

    // ReSharper disable InconsistentNaming
    private string typeName;
    private AssemblyData assembly;
    // ReSharper restore InconsistentNaming
    [NonSerialized] private Type _type;

    private Type GetTypeInfo()
    {
      return _type ?? (_type = AssemblyData
        .Unwrap(assembly).GetType(typeName, false));
    }

    #endregion

    #region Static members

    public static bool NeedWrap(Type type)
    {
      return type != null && AssemblyData.NeedWrap(type.Assembly);
    }

    public static object Wrap(Type type)
    {
      if (type == null) return null;

      var aw = AssemblyData.Wrap(type.Assembly) as AssemblyData;
      if (aw == null
        || type.Assembly.GetType(type.FullName, false) == null)
      {
        return type;
      }

      return new TypeData
      {
        typeName = type.FullName,
        assembly = aw,
      };
    }

    public static Type Unwrap(object data)
    {
      var w = data as TypeData;
      return w == null ? (Type) data : w.GetTypeInfo();
    }

    public static TypeData ForceWrap(
      Type type, SimpleXmlSerializer settings)
    {
      if (type == null) return null;
      if (type.FullName == null)
      {
        throw new SerializationException("Type name is null");
      }

      var assembly = type.Assembly;
      if (!AssemblyData.NeedWrap(assembly))
      {
        return new TypeData
        {
          typeName = Utility.GetTypeName(type, settings)
        };
      }

      return new TypeData
      {
        typeName = type.FullName,
        assembly = AssemblyData.Wrap(assembly, settings),
      };
    }

    public static Type Unwrap(TypeData data, SimpleXmlSerializer settings)
    {
      if (data.assembly == null)
        return settings.GetKnownType(data.typeName);
      var assembly = AssemblyData.Unwrap(data.assembly, settings);
      return assembly.GetType(data.typeName, false);
    }

    #endregion
  }

  /// <summary>
  ///   Wrapped as serializable the methods created by scripts
  /// </summary>
  [Serializable]
  internal class MethodWrapper
  {
    #region Instance members

    private TypeData _type;
    private string _methodName;
    [NonSerialized] private MethodInfo _info;
    const BindingFlags Flags = BindingFlags.DeclaredOnly
      | BindingFlags.Instance | BindingFlags.Static
      | BindingFlags.Public | BindingFlags.NonPublic;

    private MethodInfo GetMethodInfo()
    {
      return _info ?? (_info = TypeData.Unwrap(_type)
        .GetMethod(_methodName, Flags));
    }

    #endregion

    #region Static members

    public static object Wrap(MethodInfo info)
    {
      TypeData tw;
      Type type;
      if (info == null
        || (type = info.DeclaringType) == null
        || (tw = TypeData.Wrap(type) as TypeData) == null
        || type.GetMethod(info.Name, Flags) == null)
      {
        return info;
      }

      return new MethodWrapper
      {
        _type = tw,
        _methodName = info.Name
      };
    }

    public static MethodInfo Unwrap(object data)
    {
      var w = data as MethodWrapper;
      return w == null ? (MethodInfo) data : w.GetMethodInfo();
    }

    #endregion
  }

  /// <summary>
  ///   Wrap as serializable the anonymous objects or scripted objects
  /// </summary>
  [Serializable]
  internal sealed class SimpleObjectWrapper : ISerializable
  {
    #region Instance members

    internal readonly object Value;

    private SimpleObjectWrapper(object value)
    {
      Value = value;
    }

    private SimpleObjectWrapper(SerializationInfo info, StreamingContext context)
    {
      var type = TypeData.Unwrap(info.GetValue("Type", typeof (object)));
      var vals = (FieldValue[]) info.GetValue("Fields", typeof (FieldValue[]));
      var fields = new List<MemberInfo>();
      var objects = new List<object>();
      for (int i = 0, n = vals.Length; i < n; ++i)
      {
        var v = vals[i].Value;
        if (v == null) continue;
        objects.Add(v);
        fields.Add(type.GetField(vals[i].Key, Flags));
      }
      var result = FormatterServices.GetUninitializedObject(type);
      Value = FormatterServices.PopulateObjectMembers(
        result, fields.ToArray(), objects.ToArray());
    }

    public void GetObjectData(SerializationInfo info, StreamingContext context)
    {
      var type = Value.GetType();
      var tw = TypeData.Wrap(type);
      Debug.Assert(tw is TypeData || !type.IsSerializable);

      var members = type.GetMembers(Flags);
      var fields = new List<FieldValue>();
      foreach (var fi in members.OfType<FieldInfo>())
      {
        var v = fi.GetValue(Value);
        if (v == null) continue;
        //var check = type.GetField(fi.Name, Flags)
        fields.Add(new KeyValuePair<string, object>(
          fi.Name, v.WrapSerializable(context)));
      }

      info.AddValue("Type", tw);
      info.AddValue("Fields", fields.ToArray());
    }

    #endregion

    #region Static members

    public static object Wrap(object obj)
    {
      return IsSerializable(obj) ? obj : new SimpleObjectWrapper(obj);
    }

    private static bool IsSerializable(object obj)
    {
      var type = obj.GetType();
      return AssemblyData.Find(type.Assembly.FullName) == null
        && type.IsSerializable;
    }

    #endregion

    private const BindingFlags Flags = BindingFlags.FlattenHierarchy
      | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
  }

}
